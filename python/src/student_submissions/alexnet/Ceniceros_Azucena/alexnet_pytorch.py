# -*- coding: utf-8 -*-
"""AlexNet_pytorch.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eGnIS6GfvVgrPkzj84e9aQ-BUGxZVfRf

# **AlexNet from Scratch in PyTorch**

Instalación de librerias/herramientas necesarias
"""

import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import DataLoader
import os
import pickle
import numpy as np

from google.colab import drive
drive.mount('/content/drive')

"""Cargar el archivo CIFAR-10 y devolver el diccionario de datos"""

def unpickle(file):
   # import pickle
    with open(file, 'rb') as fo:
        dict = pickle.load(fo, encoding='bytes')
    return dict

data_dir = '/content/drive/My Drive/cifar-10-batches-py'

"""Cargar los datos de CIFAR-10"""

# Loading the training data
def load_cifar10_data(data_dir):
    train_data = []
    train_labels = []

    # Cargar los batches
    for i in range(1, 6):
        batch = unpickle(os.path.join(data_dir, f"data_batch_{i}"))
        train_data.append(batch[b'data'])
        train_labels += batch[b'labels']

   # Convertir los datos en un array y hacer reshape
    train_data = np.concatenate(train_data)
    train_data = train_data.reshape((train_data.shape[0], 3, 32, 32))

    return train_data, train_labels

train_data, train_labels = load_cifar10_data(data_dir)

    # Cargar datos de prueba y hacer reshape
test_batch = unpickle(os.path.join(data_dir, "test_batch"))
test_data = test_batch[b'data']
test_labels = test_batch[b'labels']
test_data = test_data.reshape((test_data.shape[0], 3, 32, 32))

"""Preprocesar y normalizar los datos"""

# Convertir los datos en tensores de PyTorch
train_data = torch.tensor(train_data).float()
test_data = torch.tensor(test_data).float()

# Normalizar los valores al rango de -1 a 1
train_data = (train_data / 255.0 - 0.5) / 0.5
test_data = (test_data / 255.0 - 0.5) / 0.5

# Convertir las etiquetas en tensores
train_labels = torch.tensor(train_labels)
test_labels = torch.tensor(test_labels)

# Crear DataLoaders
train_dataset = torch.utils.data.TensorDataset(train_data, train_labels)
test_dataset = torch.utils.data.TensorDataset(test_data, test_labels)

train_loader = torch.utils.data.DataLoader(train_dataset, batch_size=64, shuffle=True)
test_loader = torch.utils.data.DataLoader(test_dataset, batch_size=64, shuffle=False)

"""Define the AlexNet Model"""

class AlexNet(nn.Module):
    def __init__(self, num_classes=10):
        super(AlexNet, self).__init__()

        #Extraccion de caracteristicas

        self.features = nn.Sequential(
            nn.Conv2d(3, 64, kernel_size=3, stride=1, padding=1),
            nn.ReLU(inplace=True),
            nn.MaxPool2d(kernel_size=2, stride=2),

            nn.Conv2d(64, 192, kernel_size=3, padding=1),
            nn.ReLU(inplace=True),
            nn.MaxPool2d(kernel_size=2, stride=2),

            nn.Conv2d(192, 384, kernel_size=3, padding=1),
            nn.ReLU(inplace=True),

            nn.Conv2d(384, 256, kernel_size=3, padding=1),
            nn.ReLU(inplace=True),

            nn.Conv2d(256, 256, kernel_size=3, padding=1),
            nn.ReLU(inplace=True),
            nn.MaxPool2d(kernel_size=2, stride=2)
        )

        # Capas totalmente conectadas

        self.classifier = nn.Sequential(
            nn.Dropout(),
            nn.Linear(256 * 4 * 4, 4096),
            nn.ReLU(inplace=True),
            nn.Dropout(),
            nn.Linear(4096, 4096),
            nn.ReLU(inplace=True),
            nn.Linear(4096, num_classes)
        )

    def forward(self, x):
        x = self.features(x)
        x = x.view(x.size(0), 256 * 4 * 4)
        x = self.classifier(x)
        return x

"""Instanciar el modelo, definir la función de pérdida y el optimizador"""

model = AlexNet(num_classes=10)

criterion = nn.CrossEntropyLoss()

optimizer = optim.Adam(model.parameters(), lr=0.001)

"""Entrenamiento del modelo"""

num_epochs = 10
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
model.to(device)

for epoch in range(num_epochs):
    model.train()
    running_loss = 0.0
    correct = 0
    total = 0
    for inputs, labels in train_loader:
        inputs, labels = inputs.to(device), labels.to(device)

        optimizer.zero_grad()

        outputs = model(inputs)
        loss = criterion(outputs, labels)

        loss.backward()
        optimizer.step()

        running_loss += loss.item()
        _, predicted = torch.max(outputs, 1)
        total += labels.size(0)
        correct += (predicted == labels).sum().item()

    print(f"Epoch [{epoch+1}/{num_epochs}], Loss: {running_loss/len(train_loader):.4f}, Accuracy: {100 * correct/total:.2f}%")

"""Testing del modelo"""

model.eval()
correct = 0
total = 0
with torch.no_grad():
    for inputs, labels in test_loader:
        inputs, labels = inputs.to(device), labels.to(device)

        outputs = model(inputs)
        _, predicted = torch.max(outputs, 1)
        total += labels.size(0)
        correct += (predicted == labels).sum().item()

print(f"Accuracy: {100 * correct / total:.2f}%")